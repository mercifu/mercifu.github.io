---
layout:     post
title:      托管与非托管的区别
subtitle:   
date:       2019-05-29
author:     Sam
header-img: 
catalog: true
tags:
    - C++
    - C#
---
### 托管与非托管的区别
上一篇在 MFC 项目中调用 WPF 组件中提到托管与非托管，所以这篇就打算说一下托管代码与非托管代码的区别

#### 1. 源代码到可执行文件

源代码到可执行文件的过程是一个翻译的过程，在这个过程中，编译器会根据目标机器的环境把高级语言翻译成可以适合在目标平台运行的机器码。

编译器把C#代码编译成中间语言(IL)，将中间语言封装在一个叫程序集(assembly)的文件中，程序集中包含了描述所创建的类，方法和属性(例如安全需求)的所有元数据。运行库编译器在托管执行环境下编译中间语言（IL）使之成为本地可执行的代码，并使用数组边界和索引检查，异常处理，垃圾回收等手段确保类型的安全。

#### 2. 托管代码

托管代码在公共语言运行库(CLR)中运行。这个运行库给你的运行代码提供各种各样的服务，通常来说，他会加载和验证程序集，以此来保证中间语言的正确性。当某些方法被调用的时候，运行库把具体的方法编译成适合本地计算机运行的机械码，然后会把编译好的机械码缓存起来，以备下次调用(这就是即时编译)。随着程序集的运行，运行库会持续地提供各种服务，例如安全，内存管理，线程管理等等。这个程序被“托管”在运行库中。Visual Basic .NET和C#只能产生托管代码。如果你用这类语言写程序，那么所产生的代码就是托管代码。

#### 3. 非托管代码

非托管代码就是在Visual Studio .NET 2002发布之前所创建的代码，例如Visual Basic 6, Visual C++ 6。 最糟糕的是，连那些依然残存在你的硬盘中、拥有超过15年历史的陈旧C编译器所产生的代码都是非托管代码。非托管代码直接编译成目标计算机的机械码，这些代码只能运行在编译出它们的计算机上，或者是其它相同处理器或者几乎一样处理器的计算机上。非托管代码不能享受一些运行库所提供的服务，例如安全和内存管理等。如果非托管代码需要进行内存管理等服务，就必须显式地调用操作系统的接口，通常来说，它们会调用Windows SDK所提供的API来实现。就最近的情况来看，非托管程序会通过COM接口来获取操作系统服务。跟Visual Studio平台的其他编程语言不一样，Visual C++可以创建非托管程序。

#### 4. 区别

https://blog.51cto.com/gauyanm/581107

